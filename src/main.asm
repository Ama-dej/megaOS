.INCLUDE "m328pdef.inc"
.INCLUDE "interrupt.asm"

.CSEG
.EQU CPU_FREQ = 16000000
.EQU BAUD = 9600 
.EQU BPS = (CPU_FREQ / 16 / BAUD) - 1

.EQU RX_BUFFER_SIZE = 2^6 

START:
	CLI

	LDI R16, LOW(RAMEND)
	OUT SPL, R16
	LDI R16, HIGH(RAMEND)
	OUT SPH, R16

	LDI R16, LOW(BPS)
	LDI R17, HIGH(BPS)
	STS UBRR0L, R16
	STS UBRR0H, R17

	LDI R16, (1 << RXEN0) | (1 << TXEN0) | (1 << RXCIE0) | (1 << TXCIE0) | (1 << UDRIE0)
	STS UCSR0B, R16

	LDI R16, 1
	STS TX_BUSY, R16

	CLR R16
	STS WRITE_HEAD_L, R16
	STS READ_HEAD_L, R16

	SEI


LOOP:
	CALL GETCHAR
	CPI R16, -1 
	BREQ LOOP

	CALL PUTCHAR
	RJMP LOOP

DONT_RESET:
	RJMP LOOP

HANG:
	RJMP HANG

; Ta procedura pošlje znak v registru R16 po UART-u.
;
; R16 -> Znak, ki ga želimo poslati.
PUTCHAR:
	PUSH R17

PUTCHAR_WAIT:
	LDS R17, TX_BUSY
	CPI R17, 0 
	BRNE PUTCHAR_WAIT

	STS UDR0, R16

	LDI R17, 1 
	STS TX_BUSY, R17

	POP R17
	RET

GETCHAR:
	PUSH R17
	PUSH XL
	PUSH XH

	LDS XL, READ_HEAD_L
	LDI XH, 0x01 

	LDS R17, WRITE_HEAD_L
	CP XL, R17
	BREQ GETCHAR_OVERLAP

	LDS R17, RX_BUFFER_COUNT
	CPI R17, 0
	BREQ GETCHAR_NO_CHAR_LEFT

	DEC R17
	STS RX_BUFFER_COUNT, R17

	LD R16, X+
	ANDI XL, RX_BUFFER_SIZE - 1
	STS READ_HEAD_L, XL
	RJMP GETCHAR_OUT

GETCHAR_OVERLAP:
	LDI R16, -1 
	RJMP GETCHAR_OUT

GETCHAR_NO_CHAR_LEFT:
	LDI R16, -2

GETCHAR_OUT:
	POP XH
	POP XL
	POP R17
	RET	

.DSEG
.ORG 0x0100
RX_BUFFER: .BYTE RX_BUFFER_SIZE
WRITE_HEAD_L: .BYTE 1
READ_HEAD_L: .BYTE 1
TX_BUSY: .BYTE 1
RX_BUFFER_COUNT: .BYTE 1
